/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.35.3.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import { Cw20HookMsg, VestingSchedule, Uint64, Uint128, ExecuteMsg, Binary, Denom, Addr, Cw20ReceiveMsg, InstantiateMsg, QueryMsg, VestingAccountResponse, VestingData } from "./TokenVesting.types";
export interface TokenVestingReadOnlyInterface {
  contractAddress: string;
  vestingAccount: ({
    address,
    limit,
    startAfter
  }: {
    address: string;
    limit?: number;
    startAfter?: Denom;
  }) => Promise<VestingAccountResponse>;
}
export class TokenVestingQueryClient implements TokenVestingReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.vestingAccount = this.vestingAccount.bind(this);
  }

  vestingAccount = async ({
    address,
    limit,
    startAfter
  }: {
    address: string;
    limit?: number;
    startAfter?: Denom;
  }): Promise<VestingAccountResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      vesting_account: {
        address,
        limit,
        start_after: startAfter
      }
    });
  };
}
export interface TokenVestingInterface extends TokenVestingReadOnlyInterface {
  contractAddress: string;
  sender: string;
  receive: ({
    amount,
    msg,
    sender
  }: {
    amount: Uint128;
    msg: Binary;
    sender: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  registerVestingAccount: ({
    address,
    masterAddress,
    vestingSchedule
  }: {
    address: string;
    masterAddress?: string;
    vestingSchedule: VestingSchedule;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  deregisterVestingAccount: ({
    address,
    denom,
    leftVestingTokenRecipient,
    vestedTokenRecipient
  }: {
    address: string;
    denom: Denom;
    leftVestingTokenRecipient?: string;
    vestedTokenRecipient?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  claim: ({
    denoms,
    recipient
  }: {
    denoms: Denom[];
    recipient?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class TokenVestingClient extends TokenVestingQueryClient implements TokenVestingInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.receive = this.receive.bind(this);
    this.registerVestingAccount = this.registerVestingAccount.bind(this);
    this.deregisterVestingAccount = this.deregisterVestingAccount.bind(this);
    this.claim = this.claim.bind(this);
  }

  receive = async ({
    amount,
    msg,
    sender
  }: {
    amount: Uint128;
    msg: Binary;
    sender: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      receive: {
        amount,
        msg,
        sender
      }
    }, fee, memo, _funds);
  };
  registerVestingAccount = async ({
    address,
    masterAddress,
    vestingSchedule
  }: {
    address: string;
    masterAddress?: string;
    vestingSchedule: VestingSchedule;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      register_vesting_account: {
        address,
        master_address: masterAddress,
        vesting_schedule: vestingSchedule
      }
    }, fee, memo, _funds);
  };
  deregisterVestingAccount = async ({
    address,
    denom,
    leftVestingTokenRecipient,
    vestedTokenRecipient
  }: {
    address: string;
    denom: Denom;
    leftVestingTokenRecipient?: string;
    vestedTokenRecipient?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      deregister_vesting_account: {
        address,
        denom,
        left_vesting_token_recipient: leftVestingTokenRecipient,
        vested_token_recipient: vestedTokenRecipient
      }
    }, fee, memo, _funds);
  };
  claim = async ({
    denoms,
    recipient
  }: {
    denoms: Denom[];
    recipient?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      claim: {
        denoms,
        recipient
      }
    }, fee, memo, _funds);
  };
}